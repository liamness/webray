
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript" src="jquery.min.js"></script>
<script type="text/javascript" src="dat.gui.min.js"></script>
<title>raytracer demo</title>
<link rel=”shortcut icon” href=”favicon.ico” type=”image/x-icon” />
<style>
html, body {
	width: 100%;
	height: 100%;
}

body {
	border: 0;
	margin: 0;
}

a {
	text-decoration: none;
	color: #06f;
}

#demoWrap {
	width: 100%;
	height: 100%;
	text-align: center;
	overflow: hidden;
}

#canvas {
	position: relative;
}

#popupWrap {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
	}
	
#popup {
	position: relative;
	top: 0;
	left: 0;
	width: 500px;
	padding: 10px 20px;
	margin: 0 auto;
	text-align: center;
	background-color: #FFF;
	border: 5px solid #000;
	border-radius: 15px;
}

.text_vvlarge {
	font-family: calibri, arial, sans-serif;
	font-size: 30px;
	line-height: 1.5em;
}

.text_vlarge {
	font-family: calibri, arial, sans-serif;
	font-size: 24px;
	line-height: 1.5em;
}

.text_large {
	font-family: calibri, arial, sans-serif;
	font-size: 18px;
	line-height: 1.5em;
}

.text_normal {
	font-family: calibri, arial, sans-serif;
	font-size: 15px;
	line-height: 1.5em;
}

.text_small {
	font-family: calibri, arial, sans-serif;
	font-size: 13px;
	line-height: 1.5em;
}

.text_vsmall {
	font-family: calibri, arial, sans-serif;
	font-size: 11px;
	line-height: 1.5em;
}

.text_vvsmall {
	font-family: calibri, arial, sans-serif;
	font-size: 9px;
	line-height: 1.5em;
}
</style>
</head>

<body>
	<div id="demoWrap">
		<canvas id="canvas">If you're seeing this, it probably means your browser doesn't support WebGL, and so you can't see this lovely demo. :(</canvas>
    </div>
    <div id="popupWrap">
		<div id="popup">
			<p class="text_vlarge"><strong>Instructions:</strong></p>
			<p class="text_large">To move the view, click and drag. You can zoom by scrolling in and out. A set of extended controls, allowing for the material properties to be adjusted and the generation of screenshots, can be found in the top right.</p>
			<p class="text_vlarge"><a onclick="removeDialog()">Click here to begin.</a></p>
		</div>
	</div>
    
    <script id="shader-fs" type="x-shader/x-fragment">
	
	#ifdef GL_ES
	precision mediump float;
	#endif

	uniform vec2 uResolution;
	uniform vec3 uLight1Dir;
	uniform vec3 uLight1Color;
	uniform bool uLight1Enabled;
	uniform vec3 uLight2Dir;
	uniform vec3 uLight2Color;
	uniform bool uLight2Enabled;
	uniform vec3 uCameraPos;
	uniform int uObjectOneMaterial;
	uniform vec3 uObjectOneColor;
	uniform int uObjectTwoMaterial;
	uniform vec3 uObjectTwoColor;
	uniform int uObjectThreeMaterial;
	uniform vec3 uObjectThreeColor;
	uniform float uRefractiveIndex;

	const vec3 up = vec3(0.,1.,0.);

//height = floor plane y-coord
//ro ray origin
//rd ray direction
//height... height!
//t0 point on ray
float intersectfloor(vec3 ro, vec3 rd, float height, out float t0)
{	
	if (rd.y==0.0) {
		t0 = 100000.0;
		return 0.0;
	}
	
	t0 = -(ro.y - height)/rd.y;
	t0 = min(100000.0,t0);
	return t0;
}

// @baldwin
// see http://www.cs.unc.edu/~rademach/xroads-RT/RTarticle.html
// axis-aligned; length of side = size; slab implementation (t0 near, t1 far)
// returns positive value if there are intersections
float intersectbox( in vec3 ro, in vec3 rd, float size, out float t0, out float t1, out vec3 normal)
{
    vec3 ir = 1.0/rd; //inverse ray
    vec3 tb = ir * (vec3(-size*.5)-ro);
    vec3 tt = ir * (vec3(size*.5)-ro);
    vec3 tn = min(tt, tb);
    vec3 tx = max(tt, tb);
    vec2 t = max(tn.xx, tn.yz);
    t0 = max(t.x, t.y);
    t = min(tx.xx, tx.yz);
    t1 = min(t.x, t.y);
	float d = (t1-t0);
	vec3 i = ro + t0*rd;
	normal = step(size*.499,abs(i))*sign(i);
	if (t0<-0.01) d = t0;
	return d;
}

//calcuate sphere normals
	vec3 nSphere( in vec3 pos, in vec4 sph ){
		return (pos - sph.xyz)/sph.w;
	}

float intersectsphere( in vec3 sphPos, in vec3 ro, in vec3 rd, float rad, out float t, out vec3 normal ){
	vec3 coord = ro - sphPos.xyz;
	float b = 2.0 * dot( coord, rd );
	float c = dot( coord, coord ) - rad * rad;
	float h = b*b - 4.0*c;
	if( h < 0.0 ){
		return -1.0;
	}
	t = ( -b - sqrt( h )) / 2.0;
	
	vec3 pos = ro + t * rd;
	vec4 sph = vec4( sphPos.xyz, rad );
	normal = nSphere( pos, sph );
	
	return t;
}

float intersect(in vec3 boxPos, in vec3 sphPos, in vec3 sphPos2, in vec3 ro, in vec3 rd, out vec3 intersection, out vec3 normal, out int mode, out vec3 color, out float t) 
{
	//check box
	float tb0 = 0.0; //nearpoint
	float tb1 = 0.0; //farpoint
	vec3 boxnormal;
	float dbox = intersectbox( ro-boxPos, rd, 1.0, tb0, tb1, boxnormal );
	//float dbox = intersectsphere( boxPos, ro, rd, 1.0, tb0, boxnormal ); //uncomment to make sphere
	
	//check sphere REFLECTIVE
	float ts = 0.0;
	vec3 spherenormal;
	float ds = intersectsphere( sphPos, ro, rd, 1.0, ts, spherenormal );
	
	//check sphere REFRACTIVE
	float ts2 = 0.0;
	vec3 spherenormal2;
	float ds2 = intersectsphere( sphPos2, ro, rd, 1.0, ts2, spherenormal2 );
	
	//check floor
	float tf = 0.0; //floor point
	float dfloor = intersectfloor(ro,rd,0.,tf);
	t = tf;
	float d = dfloor;
	mode = 0; // no intersection
	float shortest = 1000000.0;
	if ( d >= 0.0 ) {
		normal = vec3( 0.0, 1.0, 0.0 );
		mode = 2; // floor
	}
	if ( dbox >= 0.0 ) {
		if(tb0<shortest){
		shortest=tb0;
		t = tb0;
		d = dbox;
		normal = boxnormal;
		mode = uObjectOneMaterial; // box
		color = uObjectOneColor;
		if ( t<0.0 ) {
			d =- 0.1;
		}
		}
	}
	if ( ds >= 0.0 ) {
		if(ts<shortest){
		shortest=ts;
		t = ts;
		d = ds;
		normal = spherenormal;
		mode = uObjectTwoMaterial; //sphere
		color = uObjectTwoColor;
		}
	}
	if ( ds2 >= 0.0 ) {
		if(ts2<shortest){
		shortest = ts2;
		t = ts2;
		d = ds2;
		normal = spherenormal2;
		mode = uObjectThreeMaterial; //refractive sphere
		color = uObjectThreeColor;
		}
	}
	intersection = ro + t * rd;
	return d;
}
				
void main(void)
{
	vec3 light1 = uLight1Dir; //light pos
	vec3 light2 = uLight2Dir; //light pos
	float radius = uCameraPos.z; //camera rad from origin
	vec3 boxPos = vec3( 0.0, 1.0, 0.0 ); //cube position
	vec3 sphPos = vec3( 2.0, 1.5, 0.0 ); //sphere position
	vec3 sphPos2 = vec3( -2.0, 1.5, 0.0 ); //refractive sphere position
	//sin(x), cos(z) = disc orbit
	vec3 eye = vec3( radius*sin(uCameraPos.x), uCameraPos.y, radius*cos(uCameraPos.x) ); //camera
	float diff = (eye.y - 1.0) / radius;
	vec3 screen = vec3( ( radius-1.0 )*sin(uCameraPos.x), uCameraPos.y - diff, ( radius-1.0 )*cos(uCameraPos.x) );
	vec2 screenSize = vec2( uResolution.x / uResolution.y, 1.0);
	vec2 uv = gl_FragCoord.xy / uResolution.xy;
	vec2 offset = screenSize * ( uv - 0.5 );
	vec3 right = cross( up, normalize( screen - eye ) );
	vec3 ro = screen + offset.y * up + offset.x * right; //ray origin
	vec3 rd = normalize( ro - eye ); //ray direction
	vec3 i = vec3( 0.0 ); //intersection
	vec3 n = vec3( 0.0 ); //normal
	int m,m2,m3; //mode (m2 for shadowcast)
	float d,lightd1,lightd2,ra,global,direct1,direct2,shade1,shade2,t,tlight1,tlight2; //ra reflectivity
	vec3 lrd1,lrd2,i2,i3,n2,n3; //lightray direction, shadow intersection, shadow normal (unused)
	i2 = vec3( 0.0 ), i3 = vec3( 0.0 ); //initialise to remove artefacts
	vec3 c = vec3( 0.0 ), c2 = vec3( 0.0 ), c3 = vec3( 0.0 ); //input colour
	vec3 col = vec3( 0.0 ); //colourisation
	vec3 ca = vec3( 0.0 ); //colourisation
	float lra = 1.0; //attenuation
	
	bool breakOut = false;
	
	for ( int reflections = 0; reflections < 10; reflections++ ) { 
		//get intersection
		d = intersect( boxPos, sphPos, sphPos2, ro, rd, i, n, m, c, t );
		
		//shadows
		global = 0.3;
		
		//shadow 1
		if( uLight1Enabled ) {
			lrd1 = normalize( light1 - i ); //light direction relative to intersection
			tlight1 = length( light1 - i ); 
			lightd1 = smoothstep( 0.5 * length( i - i2 ), 0.0, intersect( boxPos, sphPos, sphPos2, i, lrd1, i2, n2, m2, c2, t ) );
			if( m2 == 4 ){ //attenuate shadow for refractive object
				lightd1 *= 10.0;
			}
			if ( t > tlight1 ){
				lightd1 = 1.0;
			}
			direct1 = max( ( 10.0 / length( lrd1 ) ) * dot( lrd1, n ) , 0.0 );
			shade1 = global + direct1 * lightd1;
		} else {
			shade1 = 1.0;
		}
		
		//shadow 2
		if( uLight2Enabled ) {
			lrd2 = normalize( light2 - i ); //light direction relative to intersection
			tlight2 = length( light2 - i ); 
			lightd2 = smoothstep( 0.5 * length( i - i3 ), 0.0, intersect( boxPos, sphPos, sphPos2, i, lrd2, i3, n3, m3, c3, t ) );
			if( m3 == 4 ){ //attenuate shadow for refractive object
				lightd2 *= 10.0;
			}
			if ( t > tlight2 ){
				lightd2 = 1.0;
			}
			direct2 = max( ( 10.0 / length( lrd2 ) ) * dot( lrd2, n ) , 0.0 );
			shade2 = global + direct2 * lightd2;
		} else {
			shade2 = 1.0;
		}
		
		vec3 shadeCol = (shade1 * uLight1Color + shade2 * uLight2Color) / 2.0;
		
		//colours
		if ( m == 0 ) { //"SKY"
			ra = 0.0;
			col = vec3( 0.2, 0.5, 0.9 ); 
			breakOut = true;
		}
		if ( m == 1 ) { //MATTE ISH
			ra = 0.0;
			col = c * shadeCol;
			breakOut = true;
		}
		if ( m == 2 ) { //FLOOR
			ra = 0.3;
			vec2 mxz = abs( fract( i.xz ) * 2.0 - 1.0 );
			float fade = clamp( 1.0 - length( i.xz ) * 0.05, 0.0, 1.0 );
			float fc = mix( 0.5, smoothstep( 1.0, 0.9, mxz.x + mxz.y ), fade );
			col = fc * shadeCol;
		}
		if ( m == 3 ) { //SHINY
			ra = 0.2;
			col = c * shadeCol;
		}
		if ( m == 4 ) { //REFRACTIVE
			ra = 1.0;
			col = vec3( 0.0, 0.0, 0.0 );
		}
		
		ca += lra * col;
		if( breakOut ) {
			break;
		}
		
		// attenuate reflections for next iteration
		lra *= ra;
		if( m != 4 ){
			rd = reflect( rd, n );
		} else {
			rd = refract( rd, n, uRefractiveIndex );
		}
		ro = i + 0.01 * rd;
	}
	gl_FragColor = vec4( ca / (1.0+ca), 1.0 );
	//gl_FragColor = vec4( sqrt( ca ), 1.0 );
}
    
	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
	
	attribute vec2 aSquareVertexPosition;
	
    void main(void) {
        gl_Position = vec4(aSquareVertexPosition, 0.0, 1.0);
    }
    
	</script>
    
    <script type="text/javascript">
    
    window.onload = init;
    window.onresize = resizeWindow;
    
    
    /*
    	webgl Setup
    */
    
    var gl;

    function initGL(canvas) {
    
        try {
            gl = canvas.getContext("experimental-webgl", {
            	antialias: true,
            	preserveDrawingBuffer: true
            });
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
        
    }

    function getShader(gl, id) {
    
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    var shaderProgram;

    function initShaders() {
    
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.squareVertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aSquareVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.squareVertexPositionAttribute);
        
        resizeCanvas( 400, 400 );
        updateUniforms();
        
    }
    
    function updateUniforms() {
        
        //light 1 position
        var uLight1DirLoc = gl.getUniformLocation(shaderProgram, "uLight1Dir");
        gl.uniform3f(uLight1DirLoc, guiElems.light1DirX, guiElems.light1DirY, guiElems.light1DirZ);
        
        //light 1 colour
        var uLight1ColLoc = gl.getUniformLocation(shaderProgram, "uLight1Color");
        gl.uniform3f(uLight1ColLoc, guiElems.light1Col[0] / 255, guiElems.light1Col[1] / 255, guiElems.light1Col[2] / 255);
        
        //light 1 flag
        var uLight1EnabLoc = gl.getUniformLocation(shaderProgram, "uLight1Enabled");
        gl.uniform1i(uLight1EnabLoc, guiElems.light1Enab);
        
        //light 2 position
        var uLight2DirLoc = gl.getUniformLocation(shaderProgram, "uLight2Dir");
        gl.uniform3f(uLight2DirLoc, guiElems.light2DirX, guiElems.light2DirY, guiElems.light2DirZ);
        
        //light 2 colour
        var uLight2ColLoc = gl.getUniformLocation(shaderProgram, "uLight2Color");
        gl.uniform3f(uLight2ColLoc, guiElems.light2Col[0] / 255, guiElems.light2Col[1] / 255, guiElems.light2Col[2] / 255);
        
        //light 1 flag
        var uLight2EnabLoc = gl.getUniformLocation(shaderProgram, "uLight2Enabled");
        gl.uniform1i(uLight2EnabLoc, guiElems.light2Enab);
        
        //camera pos
        var uCameraPosLoc = gl.getUniformLocation(shaderProgram, "uCameraPos");
        gl.uniform3f(uCameraPosLoc, guiElems.cameraPosX, guiElems.cameraPosY, guiElems.cameraPosZ);
        
        //o1 mat
        var uObjOneMatLoc = gl.getUniformLocation(shaderProgram, "uObjectOneMaterial");
        gl.uniform1i(uObjOneMatLoc, guiElems.objectOneMat);
        
        //o1 col
        var uObjOneColLoc = gl.getUniformLocation(shaderProgram, "uObjectOneColor");
        gl.uniform3f(uObjOneColLoc, guiElems.objectOneCol[0] / 255, guiElems.objectOneCol[1] / 255, guiElems.objectOneCol[2] / 255);
        
        //o2 mat
        var uObjTwoMatLoc = gl.getUniformLocation(shaderProgram, "uObjectTwoMaterial");
        gl.uniform1i(uObjTwoMatLoc, guiElems.objectTwoMat);
        
        //o2 col
        var uObjTwoColLoc = gl.getUniformLocation(shaderProgram, "uObjectTwoColor");
        gl.uniform3f(uObjTwoColLoc, guiElems.objectTwoCol[0] / 255, guiElems.objectTwoCol[1] / 255, guiElems.objectTwoCol[2] / 255);
        
        //o3 mat
        var uObjThreeMatLoc = gl.getUniformLocation(shaderProgram, "uObjectThreeMaterial");
        gl.uniform1i(uObjThreeMatLoc, guiElems.objectThreeMat);
        
        // o3 col
        var uObjThreeColLoc = gl.getUniformLocation(shaderProgram, "uObjectThreeColor");
        gl.uniform3f(uObjThreeColLoc, guiElems.objectThreeCol[0] / 255, guiElems.objectThreeCol[1] / 255, guiElems.objectThreeCol[2] / 255);
        
        //refractive idnex
        var uRefIndexLoc = gl.getUniformLocation(shaderProgram, "uRefractiveIndex");
        gl.uniform1f(uRefIndexLoc, guiElems.refractiveIndex);
        
    }
    
    var squareVertexPositionBuffer;

    function initVertexBuffer() {
    
        squareVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        
        var vertices = [
             1.0,  1.0,
            -1.0,  1.0,
             1.0, -1.0,
            -1.0, -1.0
        ];
        
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 2;
        squareVertexPositionBuffer.numItems = 4;
        gl.vertexAttribPointer(shaderProgram.squareVertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        
    }
    
    var canvas, canvas_rect;
    
    
    /*
    	program setup
    */
    
    function init() {
    
        canvas = document.getElementById("canvas");
        canvas.addEventListener("mousedown", mouseDown);
        canvas.addEventListener("mousemove", mouseMove);
        canvas.addEventListener("mouseup", mouseUp);
        canvas.addEventListener('mousewheel', function(event){
			mouseWheel(event.wheelDelta);
			event.preventDefault();
		}, false);
		canvas.addEventListener("DOMMouseScroll", function(event){
			mouseWheel(event.detail * 10);
			event.preventDefault();
		}, false);
		
        initGL(canvas);
        initShaders();
        initVertexBuffer();
        canvas_rect = canvas.getBoundingClientRect();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
		
		initGUI();
		resizeWindow();
        draw();
        
    }
    
    var gui = new dat.GUI();
    
    var guiElems = {
    
		light1DirX: 5.0,
		light1DirY: 7.0,
		light1DirZ: 2.0,
		light1Col: [ 200, 200, 100 ],
		light1Enab: true,
		light2DirX: -3.0,
		light2DirY: 7.0,
		light2DirZ: -4.0,
		light2Col: [ 150, 150, 255 ],
		light2Enab: true,
		cameraPosX: 0.0,
		cameraPosY: 3.0,
		cameraPosZ: 6.0,
		canvasSize: 3,
		screenshot: function() {
			screenshot();
		},
		refractiveIndex: 0.9,
		objectOneMat: 1,
		objectOneCol: [ 200, 150, 100 ],
		objectTwoCol: [ 100, 100, 200 ],
		objectThreeCol: [ 100, 100, 200 ],
		objectTwoMat: 3,
		objectThreeMat: 4
		
	};
	
    function initGUI() {
    
		var f1 = gui.addFolder('Light Options');
		var f1_1 = f1.addFolder('Light 1 Options');
		var f1_2 = f1.addFolder('Light 2 Options');
		var f2 = gui.addFolder('Object Options');
		var f2_1 = f2.addFolder('Object 1 Options');
		var f2_2 = f2.addFolder('Object 2 Options');
		var f2_3 = f2.addFolder('Object 3 Options');
		var f3 = gui.addFolder('Render Options');
		
    	var controllers = [
			f1_1.add( guiElems, 'light1DirX', -10.0, 10.0 ).name('X Position'),
			f1_1.add( guiElems, 'light1DirY', 0.1, 10.0 ).name('Y Position'),
			f1_1.add( guiElems, 'light1DirZ', -10.0, 10.0 ).name('Z Position'),
			f1_1.addColor( guiElems, 'light1Col' ).name('Colour'),
			f1_1.add( guiElems, 'light1Enab' ).name('Enable'),
			f1_2.add( guiElems, 'light2DirX', -10.0, 10.0 ).name('X Position'),
			f1_2.add( guiElems, 'light2DirY', 0.1, 10.0 ).name('Y Position'),
			f1_2.add( guiElems, 'light2DirZ', -10.0, 10.0 ).name('Z Position'),
			f1_2.addColor( guiElems, 'light2Col' ).name('Colour'),
			f1_2.add( guiElems, 'light2Enab' ).name('Enable'),
			f2.add( guiElems, 'refractiveIndex', 0.0, 1.0 ).name('Refractive Index'),
			f2_1.add( guiElems, 'objectOneMat', {
				matte: 1,
				shiny: 3, 
				glass: 4
			} ).name('Material'),
			f2_1.addColor( guiElems, 'objectOneCol' ).name('Colour'),
			f2_2.add( guiElems, 'objectTwoMat', {
				matte: 1,
				shiny: 3, 
				glass: 4
			} ).name('Material'),
			f2_2.addColor( guiElems, 'objectTwoCol' ).name('Colour'),
			f2_3.add( guiElems, 'objectThreeMat', {
				matte: 1,
				shiny: 3, 
				glass: 4
			} ).name('Material'),
			f2_3.addColor( guiElems, 'objectThreeCol' ).name('Colour'),
		];
		
		for (var i = 0; i < controllers.length; i++) {
    		controllers[i].onChange( function() {
    			update();
    		});
  		}
  		
  		var sizeController = f3.add( guiElems, 'canvasSize', {
			small: 0,
			medium: 1,
			large: 2,
			fullscreen: 3
		} ).name('Canvas Size');
		sizeController.onFinishChange( function() {
			if( guiElems.canvasSize == 0 ) {
				resizeCanvas( 400, 400 );
				resizeWindow();
				draw();
			} else if( guiElems.canvasSize == 1 ) {
				resizeCanvas( 640, 480 );
				resizeWindow();
				draw();
			} else if( guiElems.canvasSize == 2 ) {
				resizeCanvas( 1080, 720 );
				resizeWindow();
				draw();
			} else if( guiElems.canvasSize == 3 ) {
				resizeWindow();
				draw();
			}
		} );
		f3.add( guiElems, 'screenshot' ).name('Screenshot');
		
    }
    
    
    /*
    	program functions
    */
    
    function resizeWindow() {
    
    	if( guiElems.canvasSize == 3 ) {
    		resizeCanvas( $(window).width(), $(window).height() );
    		$("#canvas").css( "top", 0);
    		draw();
    	} else {
    		$("#canvas").css( "top", ($(window).height() - $("#canvas").outerHeight()) / 2);
    	}
    	
    	if( $("#popup").is(":visible") ) {
    		$("#popup").css( "top", (window.innerHeight - $("#popup").outerHeight()) / 2);
    	}
    	
    }
    
    function resizeCanvas( width, height ) {
    
    	canvas.width = width;
    	canvas.height = height;
    	gl.viewportWidth = width;
        gl.viewportHeight = height;
        var uResolutionLoc = gl.getUniformLocation(shaderProgram, "uResolution");
        gl.uniform2f(uResolutionLoc, width, height);
        
    }
    
    var new_x, new_y, old_x, old_y, clicked = false, dragged = false;
    function mouseDown(event) {
    
    	new_x = old_x = event.pageX - canvas_rect.left;
    	new_y = old_y = event.pageY - canvas_rect.top;
    	clicked = true;
    	
    }
    
    function mouseMove(event) {
    
    	new_x = event.pageX - canvas_rect.left;
    	new_y = event.pageY - canvas_rect.top;
    	
    	if(clicked) {
    		
    		var diffX = ( new_x - old_x ) / $( window ).height() * 5;
    		guiElems.cameraPosX += diffX;
    		var diffY = ( new_y - old_y ) / $( window ).height() * 20;
    		var temp = guiElems.cameraPosY + diffY;
    		if( temp > 1 && temp < 10 ) {
    			guiElems.cameraPosY = temp;
    		}
    		update();
    		
    	}
    	
    	old_x = new_x;
    	old_y = new_y;
    	
    }
    
    function mouseUp(event) {
    
    	clicked = dragged = false;
    	
    }
    
    function mouseWheel(wheel) {
    
    	var wheel = event.wheelDelta;
    	var temp = guiElems.cameraPosZ - wheel * 0.005;
    	if( temp > 4 && wheel && temp < 10 ) {
    	 guiElems.cameraPosZ = temp;
    	}
    	update();
    	
    }
    
    function printDialog( content, action, timeout ) {
    
		var popup = $('#popup'); 
		popup.html( content );
	
		if( action ) {
			popup.attr( 'onclick', action );
		}
	
		if( timeout ) {
			setTimeout( removeDialog, timeout );
		}
		
		popup.css( "top", (window.innerHeight - $("#popup").outerHeight()) / 2);
		popup.fadeIn( 'fast' );
		
	}

	function removeDialog() {
	
		var popup = $('#popup'); 
		popup.removeAttr( 'onclick' );
		popup.fadeOut( 'fast' );
		
	}
	
	function screenshot() {
	
    	var data = canvas.toDataURL("image/png");
    	printDialog(
			'<p class="text_vlarge">Click <a href="' + data + '" download="screenshot">here</a> to download the screenshot.</p>',
		'removeDialog()', false );
		
	}
    
    
    /*
    	update functions
    */
    
    function update() {
    	
    	updateUniforms();
    	draw();
    	
    }
    
    function draw() {
    
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
        
    }
    
	</script>
    
</body>

</html>